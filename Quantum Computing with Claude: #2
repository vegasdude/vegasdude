#!/usr/bin/env python3
"""
Quantum Computing Project Structure Generator
Creates complete folder structure with all files and generates a ZIP archive
"""

import os
import zipfile
from pathlib import Path

def create_file(path, content):
    """Create a file with given content"""
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"Created: {path}")

def create_quantum_project(base_dir='quantum-computing'):
    """Generate complete quantum computing project structure"""
    
    # Create base directory
    os.makedirs(base_dir, exist_ok=True)
    
    # ===== ROOT README =====
    create_file(f'{base_dir}/README.md', '''# Quantum Computing Learning Journey

## Overview
Personal repository for quantum computing studies, experiments, and projects built with Claude's assistance.

## Goals
- Master quantum computing fundamentals
- Implement key quantum algorithms
- Explore real-world applications
- Build quantum circuits and simulations

## Folder Structure
- `01-fundamentals/` - Core concepts and theory
- `02-algorithms/` - Quantum algorithm implementations
- `03-code-examples/` - Working code in Qiskit, Cirq, PennyLane
- `04-applications/` - Real-world use cases
- `05-hardware/` - Quantum hardware platforms
- `06-research-notes/` - Personal notes and experiments
- `07-claude-prompts/` - Effective prompts for learning with Claude
- `configuration-files/` - Setup and config files

## Getting Started
1. Install dependencies: `pip install -r configuration-files/requirements.txt`
2. Start with fundamentals folder
3. Run example scripts in code-examples
4. Experiment and document your learning!

## Resources
- [Qiskit Documentation](https://qiskit.org/documentation/)
- [IBM Quantum Experience](https://quantum-computing.ibm.com/)
- [Cirq Documentation](https://quantumai.google/cirq)

## Progress Tracker
- [ ] Complete fundamentals
- [ ] Implement 5 core algorithms
- [ ] Build quantum ML model
- [ ] Contribute to open-source quantum project
''')

    # ===== 01-FUNDAMENTALS =====
    create_file(f'{base_dir}/01-fundamentals/qubit-basics.md', '''# Qubit Basics

## Definition
A qubit is a two-level quantum system that serves as the basic unit of quantum information.

## Mathematical Representation
|ψ⟩ = α|0⟩ + β|1⟩

Where:
- α, β are complex probability amplitudes
- |α|² + |β|² = 1 (normalization condition)
- |0⟩ and |1⟩ are basis states

## Bloch Sphere Representation
- North pole: |0⟩ state
- South pole: |1⟩ state
- Equator: superposition states
- Any pure qubit state can be represented as a point on the sphere

## Key Differences from Classical Bits
1. **Superposition**: Can be 0 AND 1 simultaneously
2. **Measurement**: Collapses the state probabilistically
3. **No-cloning theorem**: Cannot create perfect copies
4. **Continuous state space**: Infinite possible states

## Examples
- |+⟩ = (|0⟩ + |1⟩)/√2  (equal superposition)
- |-⟩ = (|0⟩ - |1⟩)/√2  (equal superposition with phase)
''')

    create_file(f'{base_dir}/01-fundamentals/superposition-entanglement.md', '''# Superposition and Entanglement

## Superposition
The ability of a quantum system to exist in multiple states simultaneously until measured.

### Mathematical Form
|ψ⟩ = α|0⟩ + β|1⟩

### Example: Hadamard Gate
After applying H gate to |0⟩:
|ψ⟩ = (1/√2)|0⟩ + (1/√2)|1⟩

This creates equal probability (50%) of measuring 0 or 1.

## Entanglement
Quantum correlation between qubits where the state of one cannot be described independently of the others.

### Bell States (Maximally Entangled)
- |Φ⁺⟩ = (1/√2)(|00⟩ + |11⟩)
- |Φ⁻⟩ = (1/√2)(|00⟩ - |11⟩)
- |Ψ⁺⟩ = (1/√2)(|01⟩ + |10⟩)
- |Ψ⁻⟩ = (1/√2)(|01⟩ - |10⟩)

### Properties
- Measurement of one qubit instantly determines the other
- No information is transmitted (no FTL communication)
- Stronger than classical correlation

### EPR Paradox
Einstein-Podolsky-Rosen thought experiment demonstrating "spooky action at a distance" - later confirmed through Bell's inequality violations.

## Applications
- Quantum teleportation
- Quantum key distribution
- Quantum computing algorithms
- Quantum sensing
''')

    create_file(f'{base_dir}/01-fundamentals/quantum-gates.md', '''# Quantum Gates Reference

## Single-Qubit Gates

### Pauli Gates
**X Gate (NOT Gate)**
- Flips |0⟩ ↔ |1⟩
- Matrix: [[0,1],[1,0]]

**Y Gate**
- Rotation around Y-axis
- Matrix: [[0,-i],[i,0]]

**Z Gate (Phase Flip)**
- Flips phase: |1⟩ → -|1⟩
- Matrix: [[1,0],[0,-1]]

### Hadamard (H) Gate
Creates superposition from basis states
- H|0⟩ = (|0⟩ + |1⟩)/√2
- H|1⟩ = (|0⟩ - |1⟩)/√2
- Matrix: (1/√2)[[1,1],[1,-1]]

### Phase Gates
**S Gate (Phase Gate)**
- Adds π/2 phase to |1⟩
- Matrix: [[1,0],[0,i]]

**T Gate (π/8 Gate)**
- Adds π/4 phase to |1⟩
- Matrix: [[1,0],[0,e^(iπ/4)]]

### Rotation Gates
**Rx(θ)**: Rotation around X-axis by angle θ
**Ry(θ)**: Rotation around Y-axis by angle θ
**Rz(θ)**: Rotation around Z-axis by angle θ

## Multi-Qubit Gates

### CNOT (Controlled-NOT)
- Two-qubit gate
- Flips target qubit if control qubit is |1⟩
- Essential for creating entanglement

### SWAP
- Exchanges states of two qubits
- Can be decomposed into three CNOT gates

### Toffoli (CCNOT)
- Three-qubit gate
- Flips target if both control qubits are |1⟩
- Universal for classical reversible computing

### Controlled-Z (CZ)
- Applies Z gate to target if control is |1⟩
- Symmetric (control and target are interchangeable)

## Gate Properties
- **Reversible**: All quantum gates are reversible
- **Unitary**: Preserve normalization (UU† = I)
- **Universal Sets**: {H, T, CNOT} can approximate any unitary
''')

    create_file(f'{base_dir}/01-fundamentals/measurement-theory.md', '''# Quantum Measurement

## Collapse Postulate
Measurement forces a quantum state to collapse from superposition to a definite classical outcome.

## Projective Measurement
- Measured value = eigenvalue of measurement operator
- Post-measurement state = corresponding eigenstate
- Process is non-deterministic but follows Born rule

## Born Rule
Probability of measuring outcome m:
P(m) = |⟨m|ψ⟩|²

Where |m⟩ is the eigenstate corresponding to outcome m.

## Measurement Bases

### Computational Basis (Z-basis)
- States: {|0⟩, |1⟩}
- Most common measurement
- Default in most quantum circuits

### Hadamard Basis (X-basis)
- States: {|+⟩, |-⟩}
- |+⟩ = (|0⟩ + |1⟩)/√2
- |-⟩ = (|0⟩ - |1⟩)/√2

### Circular Basis (Y-basis)
- States: {|R⟩, |L⟩} (right/left circular)
- Used in photonic systems

## Partial Measurement
Can measure subset of qubits in multi-qubit system:
- Measured qubits collapse
- Unmeasured qubits remain in superposition
- Creates conditional states

## Weak Measurement
- Extracts partial information without full collapse
- Used in quantum error correction
- Advanced technique for quantum metrology

## Measurement Effects
1. **Wavefunction collapse**: Destroys superposition
2. **Backaction**: Changes the system state
3. **Information gain**: Reveals classical information
4. **Irreversibility**: Cannot undo measurement

## Deferred Measurement Principle
Measurements can be moved to end of circuit without changing results (with adjustments for classical control).
''')

    # ===== 02-ALGORITHMS =====
    create_file(f'{base_dir}/02-algorithms/grovers-algorithm.md', '''# Grover's Algorithm

## Purpose
Quantum search algorithm providing quadratic speedup for searching unstructured databases.

## Complexity Comparison
- **Classical**: O(N) - must check each item
- **Quantum**: O(√N) - quadratic speedup

## Algorithm Steps
1. **Initialize**: Create uniform superposition H⊗ⁿ|0⟩
2. **Oracle**: Mark target state(s) with phase flip
3. **Diffusion**: Amplify marked states (inversion about average)
4. **Repeat**: Iterate ~√N times
5. **Measure**: High probability of finding target

## Oracle Design
Implements function f(x) that identifies solution:
- f(x) = 1 if x is solution
- f(x) = 0 otherwise

Quantum oracle: |x⟩ → (-1)^f(x)|x⟩

## Diffusion Operator (Amplitude Amplification)
Also called "inversion about average":
- Reflects amplitudes about their mean
- Increases probability of marked states
- Decreases probability of unmarked states

## Optimal Iterations
Number of iterations: ⌊π/4 * √(N/M)⌋
- N = size of search space
- M = number of solutions

## Applications
- Database search
- Cryptanalysis (attacking symmetric encryption)
- Solving NP problems (with modifications)
- Graph coloring
- Satisfiability problems

## Limitations
- Requires knowing number of solutions
- Needs quantum random access memory (QRAM)
- Speedup is "only" quadratic (not exponential)

## Geometric Interpretation
Search space forms 2D plane with:
- |ψ⟩ = superposition of non-solutions
- |ω⟩ = superposition of solutions
Each iteration rotates toward |ω⟩
''')

    create_file(f'{base_dir}/02-algorithms/shors-algorithm.md', '''# Shor's Algorithm

## Purpose
Factor large integers exponentially faster than best known classical algorithms.

## Security Implications
- Threatens RSA encryption (widely used for secure communication)
- Threatens elliptic curve cryptography
- Motivates post-quantum cryptography research

## Complexity Comparison
- **Classical (best known)**: O(exp(n^(1/3))) sub-exponential
- **Quantum (Shor's)**: O(n² log n log log n) polynomial
- **Classical (trial division)**: O(√N) exponential in bit length

## Problem: Factor N into p × q

## Algorithm Steps

### 1. Classical Preprocessing
- Check if N is even, prime, or perfect power
- Choose random a < N where gcd(a, N) = 1

### 2. Quantum Period Finding
Find period r of function: f(x) = a^x mod N
- Create superposition of all x values
- Apply modular exponentiation
- Use Quantum Fourier Transform
- Measure to find period r

### 3. Classical Post-Processing
If r is even and a^(r/2) ≠ -1 (mod N):
- Factor 1: gcd(a^(r/2) - 1, N)
- Factor 2: gcd(a^(r/2) + 1, N)

## Quantum Fourier Transform
Core component that enables period finding:
- Maps computational basis to Fourier basis
- QFT|j⟩ = (1/√N) Σ exp(2πijk/N)|k⟩
- Exponentially faster than classical FFT

## Resource Requirements
To factor n-bit number:
- Qubits needed: 2n + 3
- Circuit depth: O(n³)
- Gate count: O(n² log n log log n)

For RSA-2048:
- ~4100 qubits needed
- Millions of gates
- Currently beyond reach of existing quantum computers

## Historical Significance
- Published by Peter Shor in 1994
- First quantum algorithm with clear practical advantage
- Major driver of quantum computing research funding

## Variants
- Shor's algorithm for discrete logarithm
- Adapted for elliptic curve discrete log problem
''')

    create_file(f'{base_dir}/02-algorithms/quantum-fourier-transform.md', '''# Quantum Fourier Transform (QFT)

## Definition
Quantum analogue of the discrete Fourier transform, operating on quantum amplitudes.

## Mathematical Formula
QFT|x⟩ = (1/√N) Σ(y=0 to N-1) exp(2πixy/N)|y⟩

For n qubits: N = 2^n

## Classical vs Quantum

### Classical FFT
- Time: O(N log N)
- Space: O(N)
- Operates on N values

### Quantum QFT
- Time: O(n²) = O((log N)²)
- Space: O(n) qubits
- Operates on amplitudes in superposition
- Exponential speedup!

## Circuit Implementation
For 3 qubits:
1. Apply H gate to qubit 0
2. Apply controlled phase gates
3. Apply H gate to qubit 1
4. More controlled phases
5. Apply H gate to qubit 2
6. SWAP qubits to reverse order

Gates needed: O(n²)

## Properties
1. **Unitary**: QFT† = QFT^(-1)
2. **Efficient**: Polynomial number of gates
3. **Exact**: No approximation needed
4. **Reversible**: Can apply inverse QFT

## Applications

### Phase Estimation
Estimates eigenvalue phase of unitary operator:
U|ψ⟩ = e^(2πiφ)|ψ⟩

### Shor's Algorithm
Period finding requires QFT for:
- Finding frequency components
- Extracting period from measured values

### Quantum Simulation
- Time evolution of quantum systems
- Solving quantum chemistry problems

### Hidden Subgroup Problem
General framework including:
- Integer factorization (Shor's)
- Discrete logarithm
- Graph isomorphism

## Circuit Depth
- Depth: O(n²) for n qubits
- Can be approximated with O(n log n) depth
- Trade-off between accuracy and depth

## Comparison with Classical DFT
Classical DFT output: N complex numbers
QFT output: Quantum state with N amplitudes

**Key difference**: Cannot directly read all N amplitudes (measurement collapses state), but algorithms use QFT within larger procedures where this isn't a limitation.
''')

    # ===== 03-CODE-EXAMPLES =====
    
    # QISKIT examples
    create_file(f'{base_dir}/03-code-examples/qiskit/basic-circuits.py', '''#!/usr/bin/env python3
"""
Basic Quantum Circuits with Qiskit
Demonstrates fundamental quantum operations
"""

from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram, plot_bloch_multivector
import matplotlib.pyplot as plt

def single_qubit_demo():
    """Demonstrate single qubit gates"""
    print("\\n=== Single Qubit Operations ===")
    
    # Create circuit
    qc = QuantumCircuit(1, 1)
    qc.h(0)  # Hadamard gate creates superposition
    qc.measure(0, 0)
    
    # Simulate
    simulator = Aer.get_backend('qasm_simulator')
    result = execute(qc, simulator, shots=1000).result()
    counts = result.get_counts()
    
    print(f"Measurement results: {counts}")
    print("Expected: ~50% 0, ~50% 1")
    
    return qc

def two_qubit_demo():
    """Demonstrate two qubit operations"""
    print("\\n=== Two Qubit Operations ===")
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)       # Superposition on qubit 0
    qc.cx(0, 1)   # CNOT gate (creates entanglement)
    qc.measure_all()
    
    # Simulate
    simulator = Aer.get_backend('qasm_simulator')
    result = execute(qc, simulator, shots=1000).result()
    counts = result.get_counts()
    
    print(f"Measurement results: {counts}")
    print("Expected: ~50% 00, ~50% 11 (entangled state)")
    
    return qc

def pauli_gates_demo():
    """Demonstrate Pauli X, Y, Z gates"""
    print("\\n=== Pauli Gates ===")
    
    # X gate (bit flip)
    qc_x = QuantumCircuit(1, 1)
    qc_x.x(0)
    qc_x.measure(0, 0)
    
    # Y gate
    qc_y = QuantumCircuit(1, 1)
    qc_y.y(0)
    qc_y.measure(0, 0)
    
    # Z gate (phase flip)
    qc_z = QuantumCircuit(1, 1)
    qc_z.h(0)  # Need superposition to see Z effect
    qc_z.z(0)
    qc_z.h(0)
    qc_z.measure(0, 0)
    
    simulator = Aer.get_backend('qasm_simulator')
    
    result_x = execute(qc_x, simulator, shots=1000).result()
    result_z = execute(qc_z, simulator, shots=1000).result()
    
    print(f"X gate result: {result_x.get_counts()}")
    print(f"Z gate result: {result_z.get_counts()}")
    
    return qc_x, qc_z

def rotation_gates_demo():
    """Demonstrate rotation gates"""
    print("\\n=== Rotation Gates ===")
    
    import numpy as np
    
    qc = QuantumCircuit(1, 1)
    qc.rx(np.pi/4, 0)  # Rotate around X by π/4
    qc.measure(0, 0)
    
    simulator = Aer.get_backend('qasm_simulator')
    result = execute(qc, simulator, shots=1000).result()
    counts = result.get_counts()
    
    print(f"Rx(π/4) result: {counts}")
    
    return qc

if __name__ == "__main__":
    print("Quantum Circuit Examples with Qiskit\\n")
    print("=" * 50)
    
    single_qubit_demo()
    two_qubit_demo()
    pauli_gates_demo()
    rotation_gates_demo()
    
    print("\\n" + "=" * 50)
    print("Examples complete!")
''')

    create_file(f'{base_dir}/03-code-examples/qiskit/bell-state.py', '''#!/usr/bin/env python3
"""
Bell State Creation and Analysis
Creates all four Bell states and demonstrates quantum entanglement
"""

from qiskit import QuantumCircuit, execute, Aer
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt

def create_bell_state(bell_type='phi_plus'):
    """
    Create one of the four Bell states
    
    Args:
        bell_type: 'phi_plus', 'phi_minus', 'psi_plus', or 'psi_minus'
    
    Returns:
        Quantum circuit and measurement results
    """
    qc = QuantumCircuit(2, 2)
    
    # Create |Φ⁺⟩ = (|00⟩ + |11⟩)/√2
    if bell_type == 'phi_plus':
        qc.h(0)
        qc.cx(0, 1)
    
    # Create |Φ⁻⟩ = (|00⟩ - |11⟩)/√2
    elif bell_type == 'phi_minus':
        qc.x(0)
        qc.h(0)
        qc.cx(0, 1)
    
    # Create |Ψ⁺⟩ = (|01⟩ + |10⟩)/√2
    elif bell_type == 'psi_plus':
        qc.h(0)
        qc.x(1)
        qc.cx(0, 1)
    
    # Create |Ψ⁻⟩ = (|01⟩ - |10⟩)/√2
    elif bell_type == 'psi_minus':
        qc.x(0)
        qc.h(0)
        qc.x(1)
        qc.cx(0, 1)
    
    qc.measure([0, 1], [0, 1])
    
    # Simulate
    simulator = Aer.get_backend('qasm_simulator')
    job = execute(qc, simulator, shots=1024)
    result = job.result()
    counts = result.get_counts(qc)
    
    print(f"\\n{bell_type.upper()} Bell state")
    print(f"Results: {counts}")
    
    return qc, counts

def demonstrate_entanglement():
    """
    Demonstrate that Bell states show perfect correlation
    """
    print("\\n=== Demonstrating Quantum Entanglement ===")
    print("Bell states show perfect correlation between qubits:")
    print("- Measure qubit 0 as 0 → qubit 1 must be 0 (for Φ⁺)")
    print("- Measure qubit 0 as 1 → qubit 1 must be 1 (for Φ⁺)")
    print("\\nNo classical correlation can reproduce this!")

def test_non_locality():
    """
    Demonstrate non-local nature of entanglement
    """
    print("\\n=== Testing Non-Locality ===")
    
    # Create Bell state
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    
    # Measure in different bases
    qc_z = qc.copy()
    qc_z.measure([0, 1], [0, 1])
    
    qc_x = qc.copy()
    qc_x.h([0, 1])  # Change to X basis
    qc_x.measure([0, 1], [0, 1])
    
    simulator = Aer.get_backend('qasm_simulator')
    
    result_z = execute(qc_z, simulator, shots=1000).result()
    result_x = execute(qc_x, simulator, shots=1000).result()
    
    print(f"Z-basis measurement: {result_z.get_counts()}")
    print(f"X-basis measurement: {result_x.get_counts()}")

if __name__ == "__main__":
    print("=" * 60)
    print("Bell State Analysis - Quantum Entanglement Demonstration")
    print("=" * 60)
    
    # Create all four Bell states
    for bell_type in ['phi_plus', 'phi_minus', 'psi_plus', 'psi_minus']:
        create_bell_state(bell_type)
    
    demonstrate_entanglement()
    test_non_locality()
    
    print("\\n" + "=" * 60)
    print("Bell state examples complete!")
''')

    create_file(f'{base_dir}/03-code-examples/qiskit/grover-search.py', '''#!/usr/bin/env python3
"""
Grover's Search Algorithm Implementation
Demonstrates quantum search with quadratic speedup
"""

from qiskit import QuantumCircuit, execute, Aer
import numpy as np

def grover_oracle(marked_states, n_qubits):
    """
    Create oracle that marks target states with phase flip
    
    Args:
        marked_states: List of binary strings to mark (e.g., ['11', '01'])
        n_qubits: Number of qubits
    
    Returns:
        Quantum circuit implementing the oracle
    """
    qc = QuantumCircuit(n_qubits)
    
    for target in marked_states:
        # Flip qubits where target has '0'
        for i, bit in enumerate(target):
            if bit == '0':
                qc.x(i)
        
        # Multi-controlled Z gate
        if n_qubits == 2:
            qc.cz(0, 1)
        else:
            # For more qubits, use multi-controlled Z
            qc.h(n_qubits-1)
            qc.mcx(list(range(n_qubits-1)), n_qubits-1)
            qc.h(n_qubits-1)
        
        # Flip back
        for i, bit in enumerate(target):
            if bit == '0':
                qc.x(i)
    
    return qc

def diffusion_operator(n_qubits):
    """
    Grover diffusion operator (inversion about average)
    
    Args:
        n_qubits: Number of qubits
    
    Returns:
        Quantum circuit implementing diffusion
    """
    qc = QuantumCircuit(n_qubits)
    
    # Apply Hadamard gates
    qc.h(range(n_qubits))
    
    # Apply X gates
    qc.x(range(n_qubits))
    
    # Multi-controlled Z
    qc.h(n_qubits-1)
 